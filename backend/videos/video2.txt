0:00
hey there how's it going everybody in
0:02
this video we'll be learning how to work
0:03
with file objects in Python and some of
0:06
the useful things that we can do with
0:07
these objects so whether you use Python
0:09
for desktop or web applications you're
0:11
likely going to be interacting with
0:13
files a good bit so it's definitely a
0:15
good skill to have to know how to
0:16
properly interact with these file
0:18
objects okay so let's go ahead and dive
0:20
in so to get a file object we can use
0:23
the built-in open command so I have a
0:26
file here called test.txt in the same
0:30
directory as my python file now if I
0:32
open this file we can see that it's just
0:34
a plain text file with multiple lines so
0:37
let's see how we can open and read this
0:39
file from within python now the way I'm
0:41
going to open up the file right now
0:44
isn't the way that it's normally
0:45
recommended uh it's usually recommended
0:47
to use a context manager which I'll show
0:49
you here in just a second but to show
0:51
you why a context manager is useful let
0:54
me first show you this method for
0:56
opening files first so what we're going
0:58
to do here is we're going to say f
1:00
equals open and we're just going to open
1:03
that test.txt file now if you're working
1:07
with files from different directories
1:08
then you're going to have to pass the
1:10
path to that file into the open command
1:13
but since this file is within the same
1:15
directory as my python file then I can
1:17
just pass in the name of the file uh but
1:20
if you want to learn more about how
1:21
paths work then we uh touch on that a
1:24
little bit in the tutorial I did on the
1:26
OS module okay so the open command here
1:29
allows us to specify whether we want to
1:32
open this file for reading writing
1:34
appending or reading and writing now if
1:37
we don't specify anything then it
1:39
defaults to opening the file for reading
1:42
but I usually like to be explicit here
1:44
so let's go ahead and say that we want
1:45
to open this file for reading and we can
1:48
do this by passing in a second argument
1:51
here and that's just going to be the
1:52
string of a lower case r and we'll touch
1:55
on some of these later but if I wanted
1:58
to write to a file then it would just be
2:00
a lowercase w that I'd pass in uh
2:03
appending to a file is a lowercase a and
2:06
if I wanted to read and write to a file
2:08
then I could do an R plus but for now we
2:11
just want to read the contents of the
2:13
file so let's just pass in a lowercase R
2:16
okay so now the file is actually open
2:19
and we can print the name of the file if
2:21
I was to do a
2:22
printf. name and also before I run this
2:27
and print the name of the file out
2:29
there's one more thing that we have to
2:30
do here if we open a file like we just
2:33
did here then we need to explicitly
2:36
close the file when we're done using it
2:38
and to do this I'm going to do it by
2:40
saying f. close so now that we've closed
2:43
that file let's go ahead and run this
2:46
and you can see that it printed out the
2:48
name of the file that we opened and so
2:50
this has some more information that we
2:51
can print out also if we wanted to print
2:54
the mode that the file is currently
2:56
opened with I can do a f. mode and if I
2:59
run that you can see it prints out a
3:01
lowercase R because we open the file for
3:04
reading okay so now even though that
3:06
this works the way that we've just now
3:07
done this let me show you how to instead
3:10
open the file using a context manager
3:13
and why for most use cases you'll want
3:15
to work with files this way so if we
3:17
open the file like we did here then we
3:20
have to remember to explicitly close the
3:23
file if we don't close the file then you
3:25
can end up with leaks that cause you to
3:28
run over the maximum allowed file
3:30
descriptors on your system and your
3:32
applications could throw an error so
3:34
it's always important to make sure that
3:35
you close the files that you open so in
3:38
order to use a context manager then it's
3:42
kind of similar but we can do this using
3:44
the with keyword so we can say with then
3:47
I'm just going to copy all of this so
3:50
with open test.txt in read mode and then
3:54
here at the end I'm going to say as F
3:57
and then I'm going to put in a opening
3:59
for our block here now this can be a
4:01
little confusing to people at first
4:03
because the variable name is actually
4:05
over here on the right using as F
4:08
instead of over on the left when we said
4:10
f equals open but the benefit of these
4:13
context managers is that they allow us
4:15
to work with files from within this
4:17
block and after we exit that block of
4:19
code it'll automatically close the file
4:22
for us so we don't have to worry about
4:24
whether or not we add in these closes
4:26
here now this will also close the file
4:29
if there any exceptions that are thrown
4:31
or anything like that so that's why
4:33
using these context managers are
4:35
considered a best practice and it just
4:37
automatically takes care of all that
4:39
cleanup for us so now I'm going to go
4:41
ahead and delete my outside uh open and
4:44
close statements there now one thing
4:47
that some people don't realize is that
4:48
you actually have access to this F
4:51
variable for now I'm just going to say
4:53
pass within this context manager now we
4:56
actually have access to this file object
4:58
variable after after we exit the context
5:01
manager but the file will just be closed
5:03
so for example if I print the closed
5:06
method on F now and run that you can say
5:09
that it you can see that it returns true
5:12
but even though that we have access to
5:13
this variable here uh it is closed so
5:16
it's not like we can read from it like
5:18
if I try to read the contents from the
5:20
file and print that out then you can see
5:22
that it throws a value error here and it
5:25
says IO operation on a closed file so
5:29
for what we we're going to have to work
5:31
with this file from within this context
5:34
manager and for the rest of the video
5:36
I'll be using these context managers to
5:38
work with files since it's a good
5:39
practice but I wanted to show you the
5:41
other way first in case you see it in
5:43
examples or wondered why I wasn't doing
5:45
it that way okay so back to our file so
5:48
we just tried to read the contents from
5:50
the closed file and got our error but
5:52
let's look at how we can read the
5:54
contents from the file from here within
5:56
our context manager so let's create a
5:58
variable called
6:00
fcor contents and this will just hold
6:03
the contents of our file now if we do an
6:06
f. read and if I print this out oh and
6:10
actually I need to actually print out
6:13
that fcor contents so if I save that and
6:17
print that out then you can see that it
6:19
printed out all of the contents of our
6:21
file now if you have a small file then
6:23
this is probably what you want uh but
6:26
what if we have an extremely large file
6:28
that we want to read but you don't want
6:29
to load all of the contents of that file
6:31
into memory well there are a couple of
6:33
other methods here that we have
6:35
available for reading file contents
6:37
instead of f. read so just to look at a
6:40
couple of those I could say f. read
6:44
lines and if I print this out then you
6:47
can see that we get a list of all of the
6:49
lines in the file and it looks a little
6:51
weird because we have our new line
6:52
characters in there but if we look
6:55
through this list then it actually gets
6:57
every line of the file at a different
7:00
element of that list now instead of f.
7:03
read lines I could do f. readline and if
7:07
I save that and run it then you can see
7:09
that read line grabbed the first line of
7:12
our file now every time that we run f.
7:15
read line it gets the next line in our
7:17
file so if I was to copy all of this and
7:21
then do it again and run that now you
7:24
can see that it got the first and the
7:26
second lines from the file now this
7:28
printed out a little weird here because
7:30
the print statement uh ends with a new
7:32
line by default but if I go up here and
7:35
pass in an empty string to the end of
7:39
our print statements then it will no
7:42
longer add in that extra new line and
7:45
now you can see that those are the way
7:46
that they are in the file okay but we
7:48
still haven't solved our problem of how
7:50
we can read all of the content from an
7:52
extremely large file if we read the
7:55
entire file in all at once then we could
7:57
run out of memory and we don't want go
7:59
through and do f. readline you know
8:02
thousands of times so what we're going
8:04
to do here is instead of using readline
8:07
or read lines we can simply iterate over
8:10
the lines in a file by saying
8:13
for oh let me go to a new line here for
8:17
line in F and then from here we can just
8:21
print that line so I'm going to copy
8:23
that and save that so now let me go
8:27
ahead and comment out these lines and
8:29
run this iteration over the lines and
8:32
you can see that it printed out all of
8:34
the lines in our file now this is
8:36
efficient because it's not reading in
8:38
all of the contents from our file all at
8:40
once so it's not a memory issue that we
8:43
have to worry about what it's going to
8:44
do is it's just going to go through and
8:47
get one line at a time from the file now
8:49
this is usually good enough for most
8:51
people but sometimes you may want more
8:53
control over exactly what you're reading
8:56
from the file now if we go back I'm
8:58
going to go ahead and delete this line
9:01
if we go back to our f. read line here
9:04
and I'm going to get rid of that
9:07
one now I'm going to go back to using f.
9:11
read and if you remember this read in
9:14
the entire contents of the file so if I
9:16
run that you can see that we got the
9:18
exact same thing but with f. read we can
9:20
actually specify the amount of data that
9:22
we want to read at a time by passing in
9:25
the size as an argument so if I pass in
9:28
a one 100 to our read method and then
9:32
print this out you can see that it
9:34
printed out the first 100 characters of
9:37
our file instead of printing the whole
9:39
thing all at once now if I was to copy
9:42
this and run this again then you can see
9:46
that it printed out the rest of the file
9:49
because it picked up where it left off
9:51
and read 100 more characters of the file
9:54
now when we reach the end of the file
9:56
then read will just return an empty
9:58
string so if I was to copy this for a
10:01
third time and rerun this then you can
10:04
see that nothing happens because what
10:06
happens when we reach the end of the
10:08
file read just returns an empty string
10:11
so this print statement is just printing
10:13
out an empty string okay so how are we
10:15
going to use this technique in order to
10:18
read in a large file um so since we
10:22
don't know exactly how long the file
10:23
will be we're going to have to use some
10:25
kind of loop that just iterates over
10:27
small chunks at a time uh so instead of
10:30
hardcoding in 100 here I'm going to
10:33
create a variable here called size to
10:37
read and for now we'll just go ahead and
10:39
set that equal to 100 so now instead of
10:43
passing in 100 to f. read let's just
10:46
pass in this size to read okay so this
10:49
will grab the first 100 characters of
10:51
our file now remember when we hit the
10:53
end of the file then read will just
10:56
return an empty string so if we do a a
10:59
while loop and say while the length of f
11:04
contents is greater than zero then we
11:09
will print out the contents that we got
11:12
from read now don't run it like this yet
11:15
because this will be an infinite loop
11:17
we're never advancing the contents of
11:19
the file after it prints the contents
11:22
then we want to read in the next chunk
11:24
of characters so in order to do that
11:26
then we just have to again say F
11:29
contents equals f. read of that sized
11:34
chunk now what it's going to do after
11:36
this line here is that it's going to
11:38
kick us back out to the while loop and
11:41
it will check if we've hit the end of
11:44
the file because f. read will return an
11:47
empty string and it won't meet this
11:50
conditional so now if I go ahead and run
11:52
this then you can see that it printed
11:54
out all of the contents of our file so
11:56
to get a better idea of what's going on
11:58
here let's change the size to read to 10
12:02
characters instead of 100 characters and
12:04
every time that we print out f. contents
12:07
here instead of an empty string uh let's
12:10
make this an asteris so now if I print
12:13
this out then you can see it's a little
12:16
bit more clear That We're looping
12:17
through 10 characters at a time and it's
12:20
printing out these asteris through every
12:22
Loop so you can see that it came through
12:24
the loop here and it printed out these
12:27
and then the asteris that we know that
12:28
it's just that chunk then it printed out
12:30
the next 10 characters and then the next
12:32
10 characters and so on until we got to
12:34
the end of the file now when we read
12:36
from files you can see that it advances
12:38
its position every time so we can
12:41
actually see the current position using
12:44
F.T so what I'm going to do is I'm going
12:47
to comment out this while loop here and
12:51
down here I'm going to say print and
12:53
we'll print out
12:56
F.T so if I go ahead and run that you
12:58
can see the F.T returned 10 so it's
13:02
saying that we're currently at the 10th
13:03
position of the in the file and that's
13:06
because we've already read in 10
13:09
characters here and we can manipulate
13:11
our current position using the seek
13:14
method so to show an example of this uh
13:17
let me print the first 20 characters of
13:20
the file by running f. read twice so I'm
13:24
going to go ahead and print out the
13:25
contents after the first 10 characters
13:29
there and then I'm going to do this a
13:32
second time to get the next 10
13:34
characters and I'm going to go ahead and
13:36
take out this second uh empty string
13:39
there so that it pushes our finished
13:42
statement out of the way so now actually
13:44
let me get rid of F.T here and go ahead
13:47
and run this so we can see that it
13:50
printed out the first 20 characters of
13:52
our file now when we read in this second
13:56
chunk here it picked up at the 10th
13:59
position and read in the next 10
14:01
characters like we would expect but what
14:03
if I wanted that second read to instead
14:07
start back at the beginning of the file
14:10
and we can do this with f. seek so
14:13
between these two reads if I was to do
14:16
an f. seek of zero and save that and ran
14:22
it now you can see that it set our
14:24
position back to the beginning of the
14:27
file so the second time we read in our
14:30
contents it starts back at the beginning
14:32
instead of picking up where we left off
14:35
after the first read now we used seek
14:38
zero to start at the beginning of the
14:40
file but you can use it to change the
14:42
position to any location that you'd like
14:44
okay so now let's take a look at writing
14:46
to files and a lot of this will be
14:48
similar to reading so first of all what
14:51
happens if we try to write from within a
14:55
file that we have opened in read mode so
14:58
let's let's go ahead and try that so
15:00
I'll do an f. write and I'll just do an
15:03
f. write of test I'm going to go ahead
15:05
and get rid of that while loop also and
15:08
save that so you see when I have a file
15:12
open in read mode and try to write that
15:14
we get an error that says that this is
15:16
not writable so we have to have the file
15:19
open in write mode so now back up here
15:22
within our open statement let's create a
15:25
new file called test2.txt and and
15:29
instead of reading we are going to write
15:32
to it now in order to do that we can
15:34
just say a lowercase w instead of that
15:37
lowercase R now you can see over here in
15:39
our directory that we don't have a
15:41
test2.txt yet now if the file doesn't
15:44
exist already then this will go ahead
15:47
and create it now if the file does exist
15:50
then it will overwrite it so be careful
15:52
if you're writing to a file that already
15:54
exists now if you don't want to
15:56
overwrite a file then you can use a
15:58
lowercase a for a pending to the file
16:01
but we're going to go ahead and
16:02
overwrite this file if it exists so
16:04
first of all instead of writing to this
16:06
file I'm just going to go ahead and put
16:08
in a past statement here which basically
16:11
says don't do anything so I'm going to
16:13
go ahead and run this and you can see
16:15
that it created test2.txt so I didn't
16:19
actually have to write anything to the
16:21
file in order to create it just using
16:24
the open with the right mode we'll
16:27
create the file so now in order to write
16:30
to this file then we can just do what we
16:32
did before we can do an f.r test.txt so
16:37
I'm going to go ahead and run that now
16:39
if we go over here to test2.txt then you
16:42
can see that it wrote test to our file
16:45
now if I go back here and do another
16:47
write to this file then it's going to
16:50
pick up where we left off just like the
16:53
read method did so now if I run this and
16:56
go back to the file then you can see
16:59
that it wrote test twice back to back
17:02
now you can actually use seek when
17:03
writing files also to set the position
17:06
back to the beginning of the file and we
17:08
can do this if I go back here between
17:11
these two WR statements and I was to do
17:13
an f. seek of zero now if I run this
17:17
then you can see that the second test
17:20
overwrote the first one so seek can get
17:23
a little confusing for file WR because
17:26
it doesn't overwrite everything only
17:29
what it needs to overwrite so for
17:30
example if instead of writing the same
17:33
thing twice if I was to do an f. seek at
17:36
the beginning and write out an r as my
17:39
second one there and now if I run that
17:42
and go back to the file then you can see
17:44
that the r only overwrote the T in test
17:48
it didn't delete the rest of the content
17:51
so using file seek whenever I am writing
17:54
to files it can get a little confusing
17:56
and I don't use it a whole lot uh but
17:58
maybe there are some use cases out there
18:00
that you guys will find it uh useful for
18:03
okay so let's go ahead and pull all of
18:04
this together and use read and write on
18:07
multiple files at the same time so we're
18:10
going to use this to make a copy of our
18:13
test.txt file um so let's go ahead and
18:16
delete our test 2.txt file here so that
18:19
we don't confuse the two and I'm going
18:21
to go ahead and close that there okay so
18:24
I'm going to go ahead and get rid of
18:26
these here so first let's open our
18:29
original test.txt file in a read mode
18:34
and instead of f here I'm going to use
18:37
RF and I'll just say RF there for read
18:40
file since this is the file that we're
18:42
going to read from in order to write to
18:45
our copy so now within this width
18:48
statement here I'm going to go ahead and
18:51
let's go ahead and copy all of this and
18:54
paste another uh open within here and
18:58
I'm going to call this a testore copy.
19:01
txt and I'm going to open this in write
19:04
mode and I'm going to call this WF for
19:07
WR file now you can actually put both of
19:10
these open statements on a single line
19:12
separated by a comma but I think
19:14
readability here is pretty important and
19:17
mixing those two on one line is
19:19
sometimes difficult to understand at
19:20
least for me uh so this is usually how I
19:22
work with multiple files at a time is
19:24
putting them on two different lines um
19:27
one nested Within in the other okay so
19:30
now within here we have two files open
19:32
RF for reading our original file and WF
19:36
for writing to our copy now to do this
19:39
it's just as easy as saying for line in
19:45
RF we want to do a WF do
19:50
write of that line okay so now let's
19:53
walk over this one more time so we have
19:56
our original file opened and we're
19:58
reading from from that file and we have
20:00
a file that doesn't exist yet that's our
20:02
copy and we're writing to that file and
20:05
we're saying for each line in our
20:08
original file write that line to WF
20:12
which is the file that we are copying to
20:15
so if I go ahead and run that then you
20:18
can see that it created this test copy.
20:20
text file and if I open this you can see
20:22
that it is an exact copy of our original
20:25
okay and lastly let's look at how we can
20:27
do something similar and copy a large
20:30
picture file now this is going to be
20:32
slightly different so if I look in my
20:34
current directory that has my python
20:37
script that I'm currently running I also
20:39
have a picture of my dog here when he
20:41
was a puppy and let's go ahead and try
20:43
to copy this picture file using file
20:47
objects in Python now this file here is
20:49
called bronx. JPEG and if I just try to
20:52
replace our text files with um these
20:56
picture files and down here I'll call
21:00
this Bronx copy. jpeg now this is
21:04
exactly the same as our previous example
21:06
but we're trying to use a picture
21:08
instead of a text file now if I try to
21:11
run this you can see that we got an
21:13
error down here that says uh UTF codec
21:17
can't decode bite in position zero so in
21:21
order to work with images we're going to
21:23
have to open these files in binary mode
21:25
and all that means is that we're going
21:26
to be reading and writing bytes instead
21:29
of working with text now I'm not going
21:31
to go into the specifics but if anyone
21:33
is curious about the differences then
21:35
I'll try to leave some resources in the
21:37
description section as to what exactly
21:39
that means but for this case in order to
21:42
work with these pictures to use binary
21:44
mode we can just append a b to our read
21:50
uh R here and our write w there so now
21:53
with that one simple change if I save
21:55
that and now run it then you can see
21:58
that we do have this copied picture file
22:01
here and if I go over to finder then you
22:04
can see that that file um copied exactly
22:08
the way that the original is okay so
22:10
last thing here now I said earlier that
22:13
sometimes you want more control over
22:15
exactly what you're reading and writing
22:17
so instead of doing this line by line
22:20
let's instead uh do this in specific
22:23
chunk sizes and we saw something like
22:25
this earlier when we were learning how
22:27
to read our files so to do this let's
22:31
just do a chunk size and we'll set this
22:34
equal to
22:36
496 now you can choose different sizes
22:39
but this is the one that I'm choosing
22:40
here um so now let's do an RF chunk and
22:45
we're just going to read in a chunk of
22:48
our read file here so I'll say
22:50
rf. read and I'll pass in this chunk
22:55
size so now we're reading that much data
22:57
from our original picture so now let's
23:00
create a loop that will write these
23:02
chunks to our copy until there's nothing
23:05
left to read from the original and if
23:07
you remember from earlier to do this we
23:09
can do a while loop and while the length
23:13
of this chunk here is greater than zero
23:19
then we want to take our copy file and
23:22
write that chunk to it so I'm going to
23:25
write this chunk to our copy and then to
23:27
keep this from being an infinite loop I
23:30
have to read in the next chunk size so
23:32
I'll paste that in there to read in uh
23:36
the next Chunk from the original file so
23:39
now if I come up here and I delete this
23:42
copy that we just created so I'm going
23:44
to delete that and now I'm going to go
23:47
ahead and rerun it using the code that
23:49
we just wrote and you can see that it
23:50
made that copy there and if I go back
23:53
over to finder and open up that copy
23:56
then you can see that it made an exact
23:57
copy of our original original okay so I
24:00
think that's going to do it for this
24:01
video uh there's a lot more that we
24:02
could look at with files and I'll plan
24:04
on putting together some tutorials in
24:06
the near future for how to work with uh
24:08
temporary files inmemory files and
24:11
things like that but I hope that this
24:12
was a good introduction into working
24:14
with files and some of the useful things
24:16
that we can do with them now if you do
24:17
have any questions then feel free to ask
24:19
in the comment section below and I'll do
24:21
my best to answer those uh be sure to
24:22
subscribe for future videos and thank
24:24
you all for watching
